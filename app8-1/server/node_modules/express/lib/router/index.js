/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict';

/**
 * Module dependencies.
 * @private
 */

var Route = require('./route');
var Layer = require('./layer');
var methods = require('methods');
var mixin = require('utils-merge');
var debug = require('debug')('express:router');
var deprecate = require('depd')('express');
var flatten = require('array-flatten');
var parseUrl = require('parseurl');
var setPrototypeOf = require('setprototypeof')

/**
 * Module variables.
 * @private
 */

var objectRegExp = /^\[object (\S+)\]$/;
var slice = Array.prototype.slice;
var toString = Object.prototype.toString;

/**
 * Initialize a new `Router` with the given `options`.
 *
 * @param {Object} [options]
 * @return {Router} which is an callable function
 * @public
 */

var proto = module.exports = function(options) {
  var opts = options || {};

  function router(req, res, next) {
    router.handle(req, res, next);
  }

  // mixin Router class functions
  setPrototypeOf(router, proto)

  router.params = {};
  router._params = [];
  router.caseSensitive = opts.caseSensitive;
  router.mergeParams = opts.mergeParams;
  router.strict = opts.strict;
  router.stack = [];

  return router;
};

/**
 * Map the given param placeholder `name`(s) to the given callback.
 *
 * Parameter mapping is used to provide pre-conditions to routes
 * which use normalized placeholders. For example a _:user_id_ parameter
 * could automatically load a user's information from the database without
 * any additional code,
 *
 * The callback uses the same signature as middleware, the only difference
 * being that the value of the placeholder is passed, in this case the _id_
 * of the user. Once the `next()` function is invoked, just like middleware
 * it will continue on to execute the route, or subsequent parameter functions.
 *
 * Just like in middleware, you must either respond to the request or call next
 * to avoid stalling the request.
 *
 *  app.param('user_id', function(req, res, next, id){
 *    User.find(id, function(err, user){
 *      if (err) {
 *        return next(err);
 *      } else if (!user) {
 *        return next(new Error('failed to load user'));
 *      }
 *      req.user = user;
 *      next();
 *    });
 *  });
 *
 * @param {String} name
 * @param {Function} fn
 * @return {app} for chaining
 * @public
 */

proto.param = function param(name, fn) {
  // param logic
  if (typeof name === 'function') {
    deprecate('router.param(fn): Refactor to use path params');
    this._params.push(name);
    return;
  }

  // apply param functions
  var params = this._params;
  var len = params.length;
  var ret;

  if (name[0] === ':') {
    deprecate('router.param(' + JSON.stringify(name) + ', fn): Use router.param(' + JSON.stringify(name.slice(1)) + ', fn) instead')
    name = name.slice(1)
  }

  for (var i = 0; i < len; ++i) {
    if (ret = params[i](name, fn)) {
      fn = ret;
    }
  }

  // ensure we end up with a
  // middleware function
  if ('function' !== typeof fn) {
    throw new Error('invalid param() call for ' + name + ', got ' + fn);
  }

  (this.params[name] = this.params[name] || []).push(fn);
  return this;
};

/**
 * Dispatch a req, res into the router.
 * @private
 */

proto.handle = function handle(req, res, out) {
  var self = this;

  debug('dispatching %s %s', req.method, req.url);

  var idx = 0;
  var protohost = getProtohost(req.url) || ''
  var removed = '';
  var slashAdded = false;
  var sync = 0
  var paramcalled = {};

  // store options for OPTIONS request
  // only used if OPTIONS request
  var options = [];

  // middleware and routes
  var stack = self.stack;

  // manage inter-router variables
  var parentParams = req.params;
  var parentUrl = req.baseUrl || '';
  var done = restore(out, req, 'baseUrl', 'next', 'params');

  // setup next layer
  req.next = next;

  // for options requests, respond with a default if nothing else responds
  if (req.method === 'OPTIONS') {
    done = wrap(done, function(old, err) {
      if (err || options.length === 0) return old(err);
      sendOptionsResponse(res, options, old);
    });
  }

  // setup basic req values
  req.baseUrl = parentUrl;
  req.originalUrl = req.originalUrl || req.url;

  next();

  function next(err) {
    var layerError = err === 'route'
      ? null
      : err;

    // remove added slash
    if (slashAdded) {
      req.url = req.url.slice(1)
      slashAdded = false;
    }

    // restore altered req.url
    if (removed.length !== 0) {
      req.baseUrl = parentUrl;
      req.url = protohost + removed + req.url.slice(protohost.length)
      removed = '';
    }

    // signal to exit router
    if (layerError === 'router') {
      setImmediate(done, null)
      return
    }

    // no more matching layers
    if (idx >= stack.length) {
      setImmediate(done, layerError);
      return;
    }

    // max sync stack
    if (++sync > 100) {
      return setImmediate(next, err)
    }

    // get pathname of request
    var path = getPathname(req);

    if (path == null) {
      return done(layerError);
    }

    // find next matching layer
    var layer;
    var match;
    var route;

    while (match !== true && idx < stack.length) {
      layer = stack[idx++];
      match = matchLayer(layer, path);
      route = layer.route;

      if (typeof match !== 'boolean') {
        // hold on to layerError
        layerError = layerError || match;
      }

      if (match !== true) {
        continue;
      }

      if (!route) {
        // process non-route handlers normally
        continue;
      }

      if (layerError) {
        // routes do not match with a pending error
        match = false;
        continue;
      }

      var method = req.method;
      var has_method = route._handles_method(method);

      // build up automatic options response
      if (!has_method && method === 'OPTIONS') {
        appendMethods(options, route._options());
      }

      // don't even bother matching route
      if (!has_method && method !== 'HEAD') {
        match = false;
      }
    }

    // no match
    if (match !== true) {
      return done(layerError);
    }

    // store route for dispatch on change
    if (route) {
      req.route = route;
    }

    // Capture one-time layer values
    req.params = self.mergeParams
      ? mergeParams(layer.params, parentParams)
      : layer.params;
    var layerPath = layer.path;

    // this should be done for the layer
    self.process_params(layer, paramcalled, req, res, function (err) {
      if (err) {
        next(layerError || err)
      } else if (route) {
        layer.handle_request(req, res, next)
      } else {
        trim_prefix(layer, layerError, layerPath, path)
      }

      sync = 0
    });
  }

  function trim_prefix(layer, layerError, layerPath, path) {
    if (layerPath.length !== 0) {
      // Validate path is a prefix match
      if (layerPath !== path.slice(0, layerPath.length)) {
        next(layerError)
        return
      }

      // Validate path breaks on a path separator
      var c = path[layerPath.length]
      if (c && c !== '/' && c !== '.') return next(layerError)

      // Trim off the part of the url that matches the route
      // middleware (.use stuff) needs to have the path stripped
      debug('trim prefix (%s) from url %s', layerPath, req.url);
      removed = layerPath;
      req.url = protohost + req.url.slice(protohost.length + removed.length)

      // Ensure leading slash
      if (!protohost && req.url[0] !== '/') {
        req.url = '/' + req.url;
        slashAdded = true;
      }

      // Setup base URL (no trailing slash)
      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/'
        ? removed.substring(0, removed.length - 1)
        : removed);
    }

    debug('%s %s : %s', layer.name, layerPath, req.originalUrl);

    if (layerError) {
      layer.handle_error(layerError, req, res, next);
    } else {
      layer.handle_request(req, res, next);
    }
  }
};

/**
 * Process any parameters for the layer.
 * @private
 */

proto.process_params = function process_params(layer, called, req, res, done) {
  var params = this.params;

  // captured parameters from the layer, keys and values
  var keys = layer.keys;

  // fast track
  if (!keys || keys.length === 0) {
    return done();
  }

  var i = 0;
  var name;
  var paramIndex = 0;
  var key;
  var paramVal;
  var paramCallbacks;
  var paramCalled;

  // process params in order
  // param callbacks can be async
  function param(err) {
    if (err) {
      return done(err);
    }

    if (i >= keys.length ) {
      return done();
    }

    paramIndex = 0;
    key = keys[i++];
    name = key.name;
    paramVal = req.params[name];
    paramCallbacks = params[name];
    paramCalled = called[name];

    if (paramVal === undefined || !paramCallbacks) {
      return param();
    }

    // param previously called with same value or error occurred
    if (paramCalled && (paramCalled.match === paramVal
      || (paramCalled.error && paramCalled.error !== 'route'))) {
      // restore value
      req.params[name] = paramCalled.value;

      // next param
      return param(paramCalled.error);
    }

    called[name] = paramCalled = {
      error: null,
      match: paramVal,
      value: paramVal
    };

    paramCallback();
  }

  // single param callbacks
  function paramCallback(err) {
    var fn = paramCallbacks[paramIndex++];

    // store updated value
    paramCalled.value = req.params[key.name];

    if (err) {
      // store error
      paramCalled.error = err;
      param(err);
      return;
    }

    if (!fn) return param();

    try {
      fn(req, res, paramCallback, paramVal, key.name);
    } catch (e) {
      paramCallback(e);
    }
  }

  param();
};

/**
 * Use the given middleware function, with optional path, defaulting to "/".
 *
 * Use (like `.all`) will run for any http METHOD, but it will not add
 * handlers for those methods so OPTIONS requests will not consider `.use`
 * functions even if they could respond.
 *
 * The other difference is that _route_ path is stripped and not visible
 * to the handler function. The main effect of this feature is that mounted
 * handlers can operate without any code changes regardless of the "prefix"
 * pathname.
 *
 * @public
 */

proto.use = function use(fn) {
  var offset = 0;
  var path = '/';

  // default path to '/'
  // disambiguate router.use([fn])
  if (typeof fn !== 'function') {
    var arg = fn;

    while (Array.isArray(arg) && arg.length !== 0) {
      arg = arg[0];
    }

    // first arg is the path
    if (typeof arg !== 'function') {
      offset = 1;
      path = fn;
    }
  }

  var callbacks = flatten(slice.call(arguments, offset));

  if (callbacks.length === 0) {
    throw new TypeError('Router.use() requires a middleware function')
  }

  for (var i = 0; i < callbacks.length; i++) {
    var fn = callbacks[i];

    if (typeof fn !== 'function') {
      throw new TypeError('Router.use() requires a middleware function but got a ' + gettype(fn))
    }

    // add the middleware
    debug('use %o %s', path, fn.name || '<anonymous>')

    var layer = new Layer(path, {
      sensitive: this.caseSensitive,
      strict: false,
      end: false
    }, fn);

    layer.route = undefined;

    this.stack.push(layer);
  }

  return this;
};

/**
 * Create a new Route for the given path.
 *
 * Each route contains a separate middleware stack and VERB handlers.
 *
 * See the Route api documentation for details on adding handlers
 * and middleware to routes.
 *
 * @param {String} path
 * @return {Route}
 * @public
 */

proto.route = function route(path) {
  var route = new Route(path);

  var layer = new Layer(path, {
    sensitive: this.caseSensitive,
    strict: this.strict,
    end: true
  }, route.dispatch.bind(route));

  layer.route = route;

  this.stack.push(layer);
  return route;
};

// create Router#VERB functions
methods.concat('all').forEach(function(method){
  proto[method] = function(path){
    var route = this.route(path)
    route[method].apply(route, slice.call(arguments, 1));
    return this;
  };
});

// append methods to a list of met›r%oÄn­å©éÜ8|ŞŠçÛ÷Y×Ù²;Õ™ıâ{ŞQMÕ¡B«ÜUÕ6HÆ½Ê ù›ÜÖ‚g:P9BĞ;1‰MŸ`'_sí`ÆëDÃ5» Ìk®ú8XËªGüÿ¨/ß#Šó¼“ÚAe]A³Ië ÇØºğÁìŠfÚT¢8N³3àVv®?‰b|r-?,¨æ”ı¶µyç}ªóØ#
ì„w›k€xp÷„Vq˜Ù‡¡È¸Ñé™wj”©†·XšÿÔ‰Ş+¾Ê]Ş¹ÑCÃâª®	*1ÃĞ¤-·éå=ÿ^¥Ë›†ÍÍÃüçséàLÅàšaÈ¤S°K—YfV-3úÏf>ft[rìr½ÈaËìBCzı¢<gÄƒ!úh²FWÅzJ^á@¤ÚáŠöÊæ x}gkÿ¢å>{f6¾…³c”!Û•CL,N[(&ØòéƒVÃfµ/ÉßÕ¦Gæ\¥F,g7f·êHr |ê¢‹¼+ƒ&âHÜ£˜ûÆµâ™gH7@4?—IBMl˜ğÔ×…pÇk'Ù§×ğä;WEß	ë™z{šÜEMIŒ±/ ¶ÉßÑÜnçÀÀ™ğ?zÚÿ¡'zÀ†ï,²NÁ“FFÑyÃƒŒª°Â‹ì
o€?.”¢Æ=H^¼úòí³gŞ¹İ2`Ã‰ÃŒ--§=ÙêÀ´3×pí‡ÏÑ¡#ŠôÜñ<ÈuR!)xãHCN±hw7ï @–ğ¬í Ëi©(BÜ4PˆÑ(Y¬Wp,I¿tÔL¶QJµG(\(C¶¥–ÖYrÈær!±ïÙˆwüÇµÈˆãq?8Qµ²QjÍ@XdƒÈÃOn¨6DŞh"úÖ¢°–0Àu!CŠ•IÊq[Å<­u|ûCºU™…7×@$ô¾®shIp¾[ZŸnÚ"|ÕˆLï¤Î¢QC¦—şã»°©GÒ|³‰ˆñyÊùuVF¸ø”k/ü«¶+_ÍOodÄ±¸²qÚMºoš´Ïµ‘ÚÛ2µ¸mµ„L'Ğ!n?éĞ›2®`n®:aG†VT·wÛÓ_ĞğÏ‡“ÛnIm«Çu€’ÑÏİƒaÿÄèŠ‡à¼ëz>”¦/|Lƒ°ƒRä~ĞQS+ôåq"9mÓ^ÚdLU•“³(47U6£˜1.ï«®¯§Ìå¶»Ÿµü8Şttp¶¹â|çiæ &*ìAA!Yª1#¿­¡+ğ¤/†×Ä«×R¢óë·ßT§SİS¬ßYÿ#ŒÿXl¡ğE×$9–N™-âùpgW¯õˆ5wÕTBé±f‹Y¬¼÷¨òõˆhöÿ¦A%bŠ=xîb­+üššÉ€> .I
ıÉè+íngóğæRY˜PÃ 'ß|Ö‰:ª°©²v<¢Kæ©˜v8iÍAĞÍÖd˜ŒŒ²€À­¾K-ªë  ye™´K	¦ã"‹ÀhLÖ”GÖ*Â¬é:ó"^yZÌ°ŒèÊóÆMåİ”@²³I²\D9‚qOÌ©`ÔSm&N­7¤¢úıšÌ02’OÄì'*øÉ'ûD˜;	•İ”…É#zi®fvº.úUE²Hd¤ˆL‘†ˆÉ3²!Wõ’3Hd„Aì„O¾c¶µÊ.:×ä½tÎşRMC4ƒ¼PŞgôîçRÈ¯ÏÈ`™«¯î’mË‚Ú¶¦¡»’3G¸‘Ì¬1±Ô`x`dz´í4¶[ÚıN1¢×æÄ7.iÙñ<i…fiL	–C¤T&Ä14tÅÀ•µ +jMÁàŠ+ xw9«C2›PyÁNˆë³ÚDÍ›miÌ C]++äŠæä1°%sm¬šow¦0üÁN‘¤vc;ôY©ó0>Ækñù'„méä±4õ6(WŒè´c¶¤0Ä°‡ß‹™}Áä¡"|°¦
Â‘bÚ•ı¸8qFI?~^‹Zµ2>¸‚ä4‰ /£i9÷ê_h•ƒ¹›¶òˆ=ï¤C®º„«+¸:X¹Nj<AŒØrÇX[ÓAÏèLÎê	ËO#ÒÖØÏÑ	SBu€gìë÷Ù›ìüDv·Z@Hõˆ&P09…õÚ¦HqhÅfìSCSLÜ"(“@‡³1K³ÙL\m#¢­«à•§UÔÃˆ<ŞÇ|Î5^áˆœŸè”P¶	ÓTKRsSey¡2ŞÔÅÃáWÇÊ¯ˆ£_do‰‚HÙf¨L³ i57•<ÑgrUùœT·5ïuæğ ¾Ü×¬OYãû˜|uÊ!m…UçvåaüªV:Dğ:ù=¼¬•#dÈ
íš§+©Úˆò	Hn¨Ì.¨R»¶^–Pº´-&8ÇûbaSE˜h§ìF3)rL Y[i¦çLr² t›££ÆÌ…kª‡ê>ºıˆÀ÷$Û¶å4×ZÊÕy¹bDïo ¤\V{ƒ ÷†I¾åšh*‡‹'K$7¡5_ZC¥G¡·¢‡ˆ^OBG›‘,oòÜƒkãxåi†0¢Ïİ§]x°;!\˜"…ÑÈÈAÂ˜_O¾¹æ€5Çt¨~ı¦ 8C`R.Jò™ë gvOêaÇª5M´.QS6 adŠGáøm3‡_Ó¤õÚFuáfiË`ÕTağM«pzÀ§*•—ª;)ŒJ
³êüµáÕ)¶ÜTNóJox9«½Ù7ÀÁ\R£G{K¡;‡qHİô¸y¥Ä-™ç/ˆIÈHÕ'ªêòWÙî]V©½ÎÑ[0Ei©;'kßŠÚ¹Îñu…?lç&{Vsi}Ó½ùîÖË¢˜ÂìjŠìÖ%‘”„Ù]à3´–á©·Iİ!YJ”9¸*Çù)…›'¶âÏ×ÏnñlªOkêˆŞ=ï~²Ànàû± ‡(*¹¨­flTœ9»›31‚‹€î¡Šr¡’g¸"ºÛM²1XojÕÊvKÄahEÁqSÑo‚DK¡á,.Š\äÀöj<ƒ‰**ö¿ÑÈz©vÙ7ü…ê1~0EnŒü¸éKpne†ÇÓ‘x}’hiÂrİÕÕÂ–ÂÑéˆŠâbÇJÙy!ã0hı³æ=\<A›’¦PV*±|±ÕJ2O£„Ñ5iÛqÔ3F%ÇãPSÖP„·}¯LõX!30(p–tÜÑçló ÖVù¼è‡é$|6ÁáğÓª¹€¼]SP´¯+eşb„µqö™R²Îªzõ¢oYQxuj%9áÆ)bf<#&‡[ûàslüì»o^*éKÑ¬½-ï°İ+-ƒœò!•ÃT-¥ ›‡~Je¬©Ñ‰¯”•n«éä-˜¢rõ±Ñ;ÇÕdÏAµ‹nSt46ëî†S¢“R‡Á
£(%µH—)¹Û±8çêY(İEoÕ•ĞgCäiìµ«>ûŞˆ#º÷Üá7—ÛlâÁ'øR©R%¸fQ&F9â6eNdaxñœ=¾ÓÚš†É|¶'g×Ì Š²ÔÁk'âh<Ú'”fD^ şÔ¶äœzş‡
37‰ÆÙP
fÖ2æã¼‘Är½¢ ewÚgz¨<%ÆÌˆ^:Ÿ’ë“%’Eúòš¥,¤së4ÿ¤›Dº¶ƒgsR;¼‚¨YX’xÇ¯òKN#è¶ó{ADrÍŠ0Ïºgrv(?ˆ_8G>n2jÛ<…ÚP¤¥˜œü i#ÈFÆ‚ë‰•›8Søy½